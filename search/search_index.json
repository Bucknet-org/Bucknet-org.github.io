{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Bucknet # A pioneer trustless reputation system for money markets","title":"Intro"},{"location":"#welcome_to_bucknet","text":"A pioneer trustless reputation system for money markets","title":"Welcome to Bucknet"},{"location":"architecture/architecture/","text":"The Trustless Reputation System Architecture Design # High-Level Architecture # The Trustless Reputation system (TRs) architecture is designed in a modular architecture with lots of benefits along the way such as flexibility, scalability, reusability, and maintainability based on layered architecture. The TRs is divided into 7 layers. Each of these is broken down into smaller units or components following the same architecture: Engagement Layer : An entry point for all parties Identity Layer : universal identity for both Web2 and Web3 Data Layer : users' data stored by themselves or other parties such as data providers, IPFS, etc. Computation Layer (TEE) : off-chain trusted computation environment Execution Layer : The layer where transactions and state changes are initially processed Settlement Layer : The layer where the execution of transactions is verified and disputes are resolved Consensus Layer : all full nodes reach a consensus on the validity of state transitions Layer Design # Engagement Layer # The engagement layer is a crucial component of software architecture that focuses on creating a seamless and interactive user experience. It serves as the interface between the user and the system, enabling effective communication, decision-making, and task accomplishment. The engagement layer is responsible for presenting information, facilitating user input, and providing feedback, ultimately driving user engagement and adoption. Goals of the Engagement Layer: Improve User Adoption : Make the system easy to use, reducing barriers to entry and increasing user acceptance. Enhance User Experience : Create an engaging, intuitive, and responsive interface that delights users and encourages continued use. Increase Productivity : Streamline workflows, simplify tasks, and provide efficient tools to maximize user productivity. Provide Personalization : Tailor the experience to individual users' needs, preferences, and behaviors. Foster Engagement : Encourage users to interact with the system, explore its features, and derive value from it. There are 3 major parties in the engagement layer: User : typical user Data Consumer and Data Provider : A data consumer is an individual, system, organization, or entity that receives or utilizes data in order to perform specific tasks or make decisions. Data consumers can be internal entities within an organization, such as data analysts and business intelligence teams, or external entities, such as customers, partners, or regulatory bodies. A data provider is any entity that organizes and provides access to various users\u2019 types of data on behalf of users\u2019 permission. Data providers can be from Web2 or Web3 such as Bank, Social Media, Indexer, Cloud Storage, Data Availability, etc. Validator : A validator is a person or program that checks the accuracy, completeness, and consistency of data. Beyond validating the user\u2019s source of truth in terms of reputation, validators reach a consensus on the validity of state transitions. Identity Layer # According to the Zero Trust Architecture, the identity Layer refers to the component or module responsible for managing and verifying the identity of users, devices, or systems. This layer is critical in ensuring secure authentication, authorization, and access control. The Identity Layer typically performs the following functions: Identity management : Managing user identities, including creation, deletion, and modification. Authentication : Verifying the identity of users, devices, or systems through various authentication mechanisms (e.g., passwords, biometrics, tokens). Authorization : Determining the access levels and permissions for authenticated entities. Account management : Managing user accounts, including account provisioning and source of truth about users. Each entity owns an identity-aggregated NFT which is the individual-authenticated aggregation of web2 and web3 identities to NFTs (SBTs included). By binding multiple identities, aggregated and compossible identity information can be verified, resulting in more beneficial on-chain scenarios for individuals, such as self-authentication, social overlapping, commercial value generation from user targeting, etc. Data Layer # In a trustless reputation system, the data layer is a fundamental component that ensures the integrity, availability, and verifiability of the reputation data across a decentralized network. A trustless environment operates without the need for a central authority or trusted intermediary, relying instead on cryptographic techniques and decentralized consensus mechanisms to secure and validate transactions and interactions. Here's how the data layer in a trustless reputation system typically functions: Decentralized Storage : Reputation data is stored across multiple nodes in the network, often using distributed ledger technology like blockchain. This ensures that the data is not controlled by any single entity and is resilient to censorship, downtime, and data loss. Immutable Records : Once reputation data is recorded on the blockchain, it becomes immutable. This means it cannot be altered or deleted without the consensus of the network, which provides an audit trail and historical record of reputation scores. Transparent and Verifiable : All participants in the network can access and verify the reputation data. The transparency of the system allows users to trust the outcomes without relying on a third party. Verifiability ensures that users can independently check the validity of the reputation information. Smart Contracts : Reputation logic can be encoded into smart contracts, which automatically execute reputation-related actions or transactions without the need for intermediaries. For example, a smart contract might release funds to a service provider after verification of successful service delivery, based on their reputation score. Consensus Mechanisms : The network uses consensus algorithms to agree on the state of the reputation data. This ensures that all nodes have a synchronized view of the system, which is essential for maintaining a consistent and reliable reputation score. Incentive Mechanisms : To encourage honest participation and discourage malicious behavior, the system typically includes incentives for users who contribute to the reputation data layer. This can include rewarding node operators who maintain the network, participants who provide honest reviews, or those who identify and report fraudulent activity. Data Privacy : While transparency is important, privacy considerations must also be addressed. Reputation systems often anonymize user data to protect the privacy of individuals while still allowing for the assessment of their reputational score. Data Integrity : Cryptographic techniques such as hash functions and digital signatures are used to ensure that reputation data has not been tampered with. These techniques allow nodes to detect and reject any altered or corrupted data. Real-time Updates : The system may support real-time updates to reputation scores, allowing for dynamic and responsive reputation assessment. It is critical for users to make informed decisions based on the latest data. Scalability : To handle a large number of transactions and reputation assessments, the data layer must be scalable. Technologies like sharding, layer 2 solutions, or sidechains can help to increase the capacity of the system. Interoperability : For a trustless reputation system to be widely adopted, it should be interoperable with other systems and blockchains. This allows for a broader range of uses and the integration of various services and applications. Governance : A clear governance framework is needed to manage changes to the reputation system and resolve disputes. This is typically achieved through decentralized autonomous organizations (DAOs) or similar structures where stakeholders can propose and vote on decisions. Computation Layer (TEE): # A Trusted Execution Environment (TEE) is a secure area of a device's processor that provides a protected environment for running sensitive code and processing sensitive data. It ensures that the code and data within the TEE are isolated from the rest of the device, making it difficult for unauthorized parties to access or tamper with them. Key components of a TEE include: Secure memory : A TEE provides a separate memory space for storing sensitive data, which is isolated from the device's main memory. Secure processor : A TEE uses a dedicated processor or a special mode of the main processor to execute sensitive code. This prevents unauthorized access or tampering with the code while it's being executed. Security algorithms : A TEE uses cryptographic algorithms to protect data and code within a secure environment. This includes techniques such as encryption, authentication, and secure key management. Access control : A TEE implements strict access control policies to ensure that only authorized apps and users can access the secure environment and its resources. A computation layer, also known as a computational layer, is a logical layer in a software or systems architecture that is responsible for performing computations or processing tasks. It typically sits above lower-level layers that handle input/output and data storage, and above higher-level layers that provide a user interface or handle application-specific logic. The computation layer can include a variety of components, such as: Mathematical libraries : for performing mathematical operations and algorithms. Data processing modules : for cleaning, transforming, and otherwise processing data. Machine learning algorithms : for making predictions or classifications based on data. Simulation and modeling tools : for simulating or modeling real-world systems or processes. Execution Layer # The execution layer serves a critical role in ensuring that transactions and interactions are conducted securely and fairly without the need for a trusted third party. Here's how this type of execution layer typically works and functions. Key Components and Features: Smart Contracts : These are self-executing contracts with the terms of the agreement directly written into code. They run on the blockchain and automatically enforce and execute the terms of a trustless agreement when predetermined conditions are met. Consensus Mechanisms : The execution layer uses consensus algorithms to validate transactions and agreements across the network, making sure that all participants agree on the state of the system. Namespace and Identity Management : To foster trustless interactions, the execution layer must accurately verify and manage identities or pseudonyms of the participants without revealing personal identifying information. Economic Incentives : Since there is no central authority, the execution layer must incorporate mechanisms to incentivize honest behavior and penalize dishonesty (e.g., through token rewards for positive contributions and slashing for malicious activities). Decentralized Storage : A robust execution layer ensures that data is stored across the network to prevent tampering and censorship, often using technologies like the IPFS. Oracles Integration : To interact with external data, the execution layer may include oracles\u2014trusted nodes or decentralized services that provide verified data to smart contracts. Event Handling and Triggering : The event system in the execution layer notifies participants or smart contracts when certain actions or transactions occur, ensuring timely and relevant automated responses within the system. Validation and Execution of Transactions : The execution layer validates incoming transactions according to the network's rules and executes them if they are correct, updating the network's distributed ledger accordingly. Reputation Algorithms : These algorithms calculate and manage the trust scores of participants based on their behavior and interactions within the network. They are key in maintaining a healthy and trust-based ecosystem on the platform. Peer Verification : Peers in the network frequently perform checks on each other's behavior, such as completing tasks or maintaining service levels, contributing to the overall trustworthiness of the network. Settlement Layer # A settlement layer is a mechanism that facilitates the resolution of disputes and the settlement of transactions in a trustless reputation system. It's a layer that sits on top of the underlying reputation system, providing a way to resolve conflicts and update reputation scores in a fair and transparent manner. Key functions of a settlement layer: Dispute resolution : The settlement layer provides a mechanism for resolving disputes between parties in the reputation system. This can include resolving conflicts related to reputation scores, transaction outcomes, or other issues that may arise. Reputation score updates : The settlement layer is responsible for updating reputation scores based on the outcome of disputes or transactions. This ensures that reputation scores accurately reflect the behavior and performance of entities in the system. Incentivization : The settlement layer can provide incentives for entities to behave honestly and maintain a good reputation. For example, entities with high reputation scores may receive rewards or benefits, while those with low scores may face penalties. Security and trust : The settlement layer ensures the security and trustworthiness of the reputation system by providing a decentralized and transparent mechanism for resolving disputes and updating reputation scores. Design considerations for a settlement layer: Decentralization : The settlement layer should be decentralized to prevent any single entity from controlling the resolution of disputes or the updating of reputation scores. Transparency : The settlement layer should provide transparent and auditable records of all disputes and reputation score updates. Fairness : The settlement layer should ensure that disputes are resolved fairly and impartially, without bias towards any particular entity. Scalability : The settlement layer should be designed to handle a large volume of disputes and reputation score updates efficiently. Incentive alignment : The settlement layer should be designed to align incentives with honest behavior, ensuring that entities are motivated to maintain a good reputation. Consensus Layer # In a trustless reputation system, a consensus layer plays a crucial role in achieving consensus among different nodes or participants, despite the absence of a central authority. This is achieved through a consensus mechanism, which ensures all participants agree on the state and validity of transactions or information. Here's a brief overview of how the consensus layer works in a trustless reputation system: Transaction Proposal : A user initiates a transaction, such as posting a review or rating, that needs to be added to the system. Validation : Following the proposal, nodes validate the genuineness and legitimacy of the transaction, checking for potential fraud, spam, or other malicious activities. Reputation Calculation : Once the transaction is deemed valid, each node in the system calculates the reputation scores for the involved parties based on their history of interactions, the number of reviews, and the overall ratings received. This reputation score reflects the trustworthiness of the users. Consensus Mechanism : After calculating the reputation scores, nodes employ a consensus mechanism to agree on the updated state of the system, including the reputation scores and the transaction itself. In a trustless reputation system, common consensus mechanisms include Proof of Work (PoW), Proof of Stake (PoS), and Byzantine Fault Tolerance (BFT). Record Update : Once a consensus is reached, the new transaction (with the updated reputation scores) is added to the system, and all nodes are updated accordingly. This process is transparent, immutable, and maintains the integrity of the trustless reputation system. Reward Distribution : To incentivize participants and prevent malicious behaviors, some consensus mechanisms (e.g., PoS and DPoS) typically distribute rewards to nodes that contribute to maintaining the security and integrity of the system.","title":"Architecture"},{"location":"architecture/architecture/#the_trustless_reputation_system_architecture_design","text":"","title":"The Trustless Reputation System Architecture Design"},{"location":"architecture/architecture/#high-level_architecture","text":"The Trustless Reputation system (TRs) architecture is designed in a modular architecture with lots of benefits along the way such as flexibility, scalability, reusability, and maintainability based on layered architecture. The TRs is divided into 7 layers. Each of these is broken down into smaller units or components following the same architecture: Engagement Layer : An entry point for all parties Identity Layer : universal identity for both Web2 and Web3 Data Layer : users' data stored by themselves or other parties such as data providers, IPFS, etc. Computation Layer (TEE) : off-chain trusted computation environment Execution Layer : The layer where transactions and state changes are initially processed Settlement Layer : The layer where the execution of transactions is verified and disputes are resolved Consensus Layer : all full nodes reach a consensus on the validity of state transitions","title":"High-Level Architecture"},{"location":"architecture/architecture/#layer_design","text":"","title":"Layer Design"},{"location":"architecture/architecture/#engagement_layer","text":"The engagement layer is a crucial component of software architecture that focuses on creating a seamless and interactive user experience. It serves as the interface between the user and the system, enabling effective communication, decision-making, and task accomplishment. The engagement layer is responsible for presenting information, facilitating user input, and providing feedback, ultimately driving user engagement and adoption. Goals of the Engagement Layer: Improve User Adoption : Make the system easy to use, reducing barriers to entry and increasing user acceptance. Enhance User Experience : Create an engaging, intuitive, and responsive interface that delights users and encourages continued use. Increase Productivity : Streamline workflows, simplify tasks, and provide efficient tools to maximize user productivity. Provide Personalization : Tailor the experience to individual users' needs, preferences, and behaviors. Foster Engagement : Encourage users to interact with the system, explore its features, and derive value from it. There are 3 major parties in the engagement layer: User : typical user Data Consumer and Data Provider : A data consumer is an individual, system, organization, or entity that receives or utilizes data in order to perform specific tasks or make decisions. Data consumers can be internal entities within an organization, such as data analysts and business intelligence teams, or external entities, such as customers, partners, or regulatory bodies. A data provider is any entity that organizes and provides access to various users\u2019 types of data on behalf of users\u2019 permission. Data providers can be from Web2 or Web3 such as Bank, Social Media, Indexer, Cloud Storage, Data Availability, etc. Validator : A validator is a person or program that checks the accuracy, completeness, and consistency of data. Beyond validating the user\u2019s source of truth in terms of reputation, validators reach a consensus on the validity of state transitions.","title":"Engagement Layer"},{"location":"architecture/architecture/#identity_layer","text":"According to the Zero Trust Architecture, the identity Layer refers to the component or module responsible for managing and verifying the identity of users, devices, or systems. This layer is critical in ensuring secure authentication, authorization, and access control. The Identity Layer typically performs the following functions: Identity management : Managing user identities, including creation, deletion, and modification. Authentication : Verifying the identity of users, devices, or systems through various authentication mechanisms (e.g., passwords, biometrics, tokens). Authorization : Determining the access levels and permissions for authenticated entities. Account management : Managing user accounts, including account provisioning and source of truth about users. Each entity owns an identity-aggregated NFT which is the individual-authenticated aggregation of web2 and web3 identities to NFTs (SBTs included). By binding multiple identities, aggregated and compossible identity information can be verified, resulting in more beneficial on-chain scenarios for individuals, such as self-authentication, social overlapping, commercial value generation from user targeting, etc.","title":"Identity Layer"},{"location":"architecture/architecture/#data_layer","text":"In a trustless reputation system, the data layer is a fundamental component that ensures the integrity, availability, and verifiability of the reputation data across a decentralized network. A trustless environment operates without the need for a central authority or trusted intermediary, relying instead on cryptographic techniques and decentralized consensus mechanisms to secure and validate transactions and interactions. Here's how the data layer in a trustless reputation system typically functions: Decentralized Storage : Reputation data is stored across multiple nodes in the network, often using distributed ledger technology like blockchain. This ensures that the data is not controlled by any single entity and is resilient to censorship, downtime, and data loss. Immutable Records : Once reputation data is recorded on the blockchain, it becomes immutable. This means it cannot be altered or deleted without the consensus of the network, which provides an audit trail and historical record of reputation scores. Transparent and Verifiable : All participants in the network can access and verify the reputation data. The transparency of the system allows users to trust the outcomes without relying on a third party. Verifiability ensures that users can independently check the validity of the reputation information. Smart Contracts : Reputation logic can be encoded into smart contracts, which automatically execute reputation-related actions or transactions without the need for intermediaries. For example, a smart contract might release funds to a service provider after verification of successful service delivery, based on their reputation score. Consensus Mechanisms : The network uses consensus algorithms to agree on the state of the reputation data. This ensures that all nodes have a synchronized view of the system, which is essential for maintaining a consistent and reliable reputation score. Incentive Mechanisms : To encourage honest participation and discourage malicious behavior, the system typically includes incentives for users who contribute to the reputation data layer. This can include rewarding node operators who maintain the network, participants who provide honest reviews, or those who identify and report fraudulent activity. Data Privacy : While transparency is important, privacy considerations must also be addressed. Reputation systems often anonymize user data to protect the privacy of individuals while still allowing for the assessment of their reputational score. Data Integrity : Cryptographic techniques such as hash functions and digital signatures are used to ensure that reputation data has not been tampered with. These techniques allow nodes to detect and reject any altered or corrupted data. Real-time Updates : The system may support real-time updates to reputation scores, allowing for dynamic and responsive reputation assessment. It is critical for users to make informed decisions based on the latest data. Scalability : To handle a large number of transactions and reputation assessments, the data layer must be scalable. Technologies like sharding, layer 2 solutions, or sidechains can help to increase the capacity of the system. Interoperability : For a trustless reputation system to be widely adopted, it should be interoperable with other systems and blockchains. This allows for a broader range of uses and the integration of various services and applications. Governance : A clear governance framework is needed to manage changes to the reputation system and resolve disputes. This is typically achieved through decentralized autonomous organizations (DAOs) or similar structures where stakeholders can propose and vote on decisions.","title":"Data Layer"},{"location":"architecture/architecture/#computation_layer_tee","text":"A Trusted Execution Environment (TEE) is a secure area of a device's processor that provides a protected environment for running sensitive code and processing sensitive data. It ensures that the code and data within the TEE are isolated from the rest of the device, making it difficult for unauthorized parties to access or tamper with them. Key components of a TEE include: Secure memory : A TEE provides a separate memory space for storing sensitive data, which is isolated from the device's main memory. Secure processor : A TEE uses a dedicated processor or a special mode of the main processor to execute sensitive code. This prevents unauthorized access or tampering with the code while it's being executed. Security algorithms : A TEE uses cryptographic algorithms to protect data and code within a secure environment. This includes techniques such as encryption, authentication, and secure key management. Access control : A TEE implements strict access control policies to ensure that only authorized apps and users can access the secure environment and its resources. A computation layer, also known as a computational layer, is a logical layer in a software or systems architecture that is responsible for performing computations or processing tasks. It typically sits above lower-level layers that handle input/output and data storage, and above higher-level layers that provide a user interface or handle application-specific logic. The computation layer can include a variety of components, such as: Mathematical libraries : for performing mathematical operations and algorithms. Data processing modules : for cleaning, transforming, and otherwise processing data. Machine learning algorithms : for making predictions or classifications based on data. Simulation and modeling tools : for simulating or modeling real-world systems or processes.","title":"Computation Layer (TEE):"},{"location":"architecture/architecture/#execution_layer","text":"The execution layer serves a critical role in ensuring that transactions and interactions are conducted securely and fairly without the need for a trusted third party. Here's how this type of execution layer typically works and functions. Key Components and Features: Smart Contracts : These are self-executing contracts with the terms of the agreement directly written into code. They run on the blockchain and automatically enforce and execute the terms of a trustless agreement when predetermined conditions are met. Consensus Mechanisms : The execution layer uses consensus algorithms to validate transactions and agreements across the network, making sure that all participants agree on the state of the system. Namespace and Identity Management : To foster trustless interactions, the execution layer must accurately verify and manage identities or pseudonyms of the participants without revealing personal identifying information. Economic Incentives : Since there is no central authority, the execution layer must incorporate mechanisms to incentivize honest behavior and penalize dishonesty (e.g., through token rewards for positive contributions and slashing for malicious activities). Decentralized Storage : A robust execution layer ensures that data is stored across the network to prevent tampering and censorship, often using technologies like the IPFS. Oracles Integration : To interact with external data, the execution layer may include oracles\u2014trusted nodes or decentralized services that provide verified data to smart contracts. Event Handling and Triggering : The event system in the execution layer notifies participants or smart contracts when certain actions or transactions occur, ensuring timely and relevant automated responses within the system. Validation and Execution of Transactions : The execution layer validates incoming transactions according to the network's rules and executes them if they are correct, updating the network's distributed ledger accordingly. Reputation Algorithms : These algorithms calculate and manage the trust scores of participants based on their behavior and interactions within the network. They are key in maintaining a healthy and trust-based ecosystem on the platform. Peer Verification : Peers in the network frequently perform checks on each other's behavior, such as completing tasks or maintaining service levels, contributing to the overall trustworthiness of the network.","title":"Execution Layer"},{"location":"architecture/architecture/#settlement_layer","text":"A settlement layer is a mechanism that facilitates the resolution of disputes and the settlement of transactions in a trustless reputation system. It's a layer that sits on top of the underlying reputation system, providing a way to resolve conflicts and update reputation scores in a fair and transparent manner. Key functions of a settlement layer: Dispute resolution : The settlement layer provides a mechanism for resolving disputes between parties in the reputation system. This can include resolving conflicts related to reputation scores, transaction outcomes, or other issues that may arise. Reputation score updates : The settlement layer is responsible for updating reputation scores based on the outcome of disputes or transactions. This ensures that reputation scores accurately reflect the behavior and performance of entities in the system. Incentivization : The settlement layer can provide incentives for entities to behave honestly and maintain a good reputation. For example, entities with high reputation scores may receive rewards or benefits, while those with low scores may face penalties. Security and trust : The settlement layer ensures the security and trustworthiness of the reputation system by providing a decentralized and transparent mechanism for resolving disputes and updating reputation scores. Design considerations for a settlement layer: Decentralization : The settlement layer should be decentralized to prevent any single entity from controlling the resolution of disputes or the updating of reputation scores. Transparency : The settlement layer should provide transparent and auditable records of all disputes and reputation score updates. Fairness : The settlement layer should ensure that disputes are resolved fairly and impartially, without bias towards any particular entity. Scalability : The settlement layer should be designed to handle a large volume of disputes and reputation score updates efficiently. Incentive alignment : The settlement layer should be designed to align incentives with honest behavior, ensuring that entities are motivated to maintain a good reputation.","title":"Settlement Layer"},{"location":"architecture/architecture/#consensus_layer","text":"In a trustless reputation system, a consensus layer plays a crucial role in achieving consensus among different nodes or participants, despite the absence of a central authority. This is achieved through a consensus mechanism, which ensures all participants agree on the state and validity of transactions or information. Here's a brief overview of how the consensus layer works in a trustless reputation system: Transaction Proposal : A user initiates a transaction, such as posting a review or rating, that needs to be added to the system. Validation : Following the proposal, nodes validate the genuineness and legitimacy of the transaction, checking for potential fraud, spam, or other malicious activities. Reputation Calculation : Once the transaction is deemed valid, each node in the system calculates the reputation scores for the involved parties based on their history of interactions, the number of reviews, and the overall ratings received. This reputation score reflects the trustworthiness of the users. Consensus Mechanism : After calculating the reputation scores, nodes employ a consensus mechanism to agree on the updated state of the system, including the reputation scores and the transaction itself. In a trustless reputation system, common consensus mechanisms include Proof of Work (PoW), Proof of Stake (PoS), and Byzantine Fault Tolerance (BFT). Record Update : Once a consensus is reached, the new transaction (with the updated reputation scores) is added to the system, and all nodes are updated accordingly. This process is transparent, immutable, and maintains the integrity of the trustless reputation system. Reward Distribution : To incentivize participants and prevent malicious behaviors, some consensus mechanisms (e.g., PoS and DPoS) typically distribute rewards to nodes that contribute to maintaining the security and integrity of the system.","title":"Consensus Layer"},{"location":"consensus/architecture_overview/","text":"Considerations # Here are some major considerations when it comes to design PoR for a trustless reputation system: Reputation Score Calculation : Each participant (data provider, validator, or user, etc.) in the network is assigned a reputation score. This score could be based on various factors, such as historical behavior, uptime, contributions to the network, security measures implemented, and feedback from other network participants. The mechanism for calculating reputation must be carefully designed to prevent manipulation and ensure that it accurately reflects each participant's trustworthiness and contributions to the network. Identity Verification : To prevent sybil attacks (where a single user creates multiple identities), participants must undergo a thorough identity verification process. This ensures that the reputation score is tied to a real-world entity. On the other hand, this might raise privacy concerns. Validator Selection : When it comes time to create new blocks, the network selects validators based on their reputation scores. Nodes with higher reputations have a greater chance of being chosen to participate in the consensus process. And a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Block Creation and Validation : Once selected, validators are responsible for checking transactions, bundling them into blocks, and proposing these blocks to the network. Other nodes with high reputations then verify the proposed block. Consensus Finality : The block is considered valid and is added to the blockchain after a certain percentage of the network's reputational power has confirmed its validity. This reduces the likelihood of forks and ensures faster transaction finality. Reputation Updates : The reputation scores of participants are continuously updated based on their ongoing behavior and contributions. Malicious actors or those failing to maintain network standards would see their reputation scores decrease, reducing their influence in the consensus process. Incentives and Penalties : Participants are incentivized to maintain a good reputation to earn block rewards and transaction fees. Conversely, if a participant acts maliciously or fails to perform their duties, they may be penalized through reduced reputation scores or exclusion from the consensus process. Enhanced Security : By tying the consensus power to a measurable and adjustable reputation score, PoR aims to enhance the security of the network. It becomes more costly for attackers to build a significant enough reputation to disrupt the network compared to simply acquiring hash power or coins for a PoW or PoS system. Network Governance : PoR can also be integrated with on-chain governance mechanisms, allowing participants to vote on network upgrades and changes based on their reputation scores. Transparency and Auditability : The reputation system must be transparent and auditable to ensure trust in the consensus mechanism. All participants should be able to understand how reputation scores are calculated and how they affect the consensus process. Cryptographic Primitives # Hash Functions # We use very secure hash functions generated with the Elliptic Curve Cryptography to generate all types of encryption needed. This method is both efficient and performant. It takes any arbitrarily long string and converts it to a fixed-length string. The main characteristics of this hash function is that for a given message, it is easy to compute the hash; but given the hash, it is difficult to compute the message. Hash functions that demonstrate this property are referred to as one-way hash functions. Digital Signatures # Digital signatures enable the verification of a message. This verification ensures that a message originated from a particular node. Digital signatures are usually a public key, denoted by pki, used for verifying the signature of node i and a corresponding secret key, denoted by ski, used by node i for signing a message. This process is referred to as encryption. To prevent another node or a malicious node from impersonation, a node should not reveal this key. The purpose of the public key is to verify a signature generated by a secret key belonging to a node in the network. A digital signature scheme usually consists of three distinct parts: A key generation algorithm, A signing algorithm, and A verification algorithm. The key generation algorithm is used to generate a new set of key pairs. The main property required from a digital signature scheme is that of security. Without knowledge of a secret key, it is infeasible to find a string that passes the verification algorithm. Event System # The concept of an event here is similar to traditional distributed algorithms where each event is defined as a unit of computation across a set of nodes. An event can be described as a tuple where pi is the node at which the event occurs, timestamp representing the exact time the event occurred, and information about the event. This definition is based on the more general formalism from distributed systems where each node of a distributed computation is a state machine and the computation causes a change of state. Information Propagation # Information propagation here deals with two main aspects: the first is about propagating information from a group of nodes to all the other nodes in the network. The other aspect is the propagation of information between two interacting nodes. The goal of information propagation is to provide every node in the network with the most recent information. This information propagation is the essence of communication in a distributed setting. Nodes in the network communicate by transmitting and receiving messages. A Message is therefore a unit of communication. A more general definition is that a message is just a finite sequence of bits. In a distributed environment where information is constantly flowing because of the interactions, there needs to be: An efficient mechanism for distributing this information i.e publish and An efficient mechanism to allow nodes to receive these specific kinds of information i.e subscribe. Specifically, in our scheme, we use a Pub-Sub pattern as the medium for information propagation. Voting # The goal of voting is to aggregate individual preferences among a group into a single group ranking. Weighted voting is a voting method that affords certain nodes more privileges on the outcome of the vote than other nodes based on some specific context for which the voting system is deployed. Weighted voting is a form of social choice system originating from the domain of cooperative game theory [1]. They essentially model decision-making processes in which a set of voters make decisions about the outcome of an issue. Each voter is allocated a numeric weight, and the decision is carried out only if the sum of weights of voters in favor of it meets or exceeds some specific given threshold, called the quota. References: # [1] G. Chalkiadakis, E. Elkind, and M. Wooldridge, \u201cComputational aspects of cooperative game theory,\u201d Synthesis Lectures on Artificial Intelligence and Machine Learning, vol. 5, no. 6, pp. 1\u2013168, 2011.","title":"Architecture Overview"},{"location":"consensus/architecture_overview/#considerations","text":"Here are some major considerations when it comes to design PoR for a trustless reputation system: Reputation Score Calculation : Each participant (data provider, validator, or user, etc.) in the network is assigned a reputation score. This score could be based on various factors, such as historical behavior, uptime, contributions to the network, security measures implemented, and feedback from other network participants. The mechanism for calculating reputation must be carefully designed to prevent manipulation and ensure that it accurately reflects each participant's trustworthiness and contributions to the network. Identity Verification : To prevent sybil attacks (where a single user creates multiple identities), participants must undergo a thorough identity verification process. This ensures that the reputation score is tied to a real-world entity. On the other hand, this might raise privacy concerns. Validator Selection : When it comes time to create new blocks, the network selects validators based on their reputation scores. Nodes with higher reputations have a greater chance of being chosen to participate in the consensus process. And a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Block Creation and Validation : Once selected, validators are responsible for checking transactions, bundling them into blocks, and proposing these blocks to the network. Other nodes with high reputations then verify the proposed block. Consensus Finality : The block is considered valid and is added to the blockchain after a certain percentage of the network's reputational power has confirmed its validity. This reduces the likelihood of forks and ensures faster transaction finality. Reputation Updates : The reputation scores of participants are continuously updated based on their ongoing behavior and contributions. Malicious actors or those failing to maintain network standards would see their reputation scores decrease, reducing their influence in the consensus process. Incentives and Penalties : Participants are incentivized to maintain a good reputation to earn block rewards and transaction fees. Conversely, if a participant acts maliciously or fails to perform their duties, they may be penalized through reduced reputation scores or exclusion from the consensus process. Enhanced Security : By tying the consensus power to a measurable and adjustable reputation score, PoR aims to enhance the security of the network. It becomes more costly for attackers to build a significant enough reputation to disrupt the network compared to simply acquiring hash power or coins for a PoW or PoS system. Network Governance : PoR can also be integrated with on-chain governance mechanisms, allowing participants to vote on network upgrades and changes based on their reputation scores. Transparency and Auditability : The reputation system must be transparent and auditable to ensure trust in the consensus mechanism. All participants should be able to understand how reputation scores are calculated and how they affect the consensus process.","title":"Considerations"},{"location":"consensus/architecture_overview/#cryptographic_primitives","text":"","title":"Cryptographic Primitives"},{"location":"consensus/architecture_overview/#hash_functions","text":"We use very secure hash functions generated with the Elliptic Curve Cryptography to generate all types of encryption needed. This method is both efficient and performant. It takes any arbitrarily long string and converts it to a fixed-length string. The main characteristics of this hash function is that for a given message, it is easy to compute the hash; but given the hash, it is difficult to compute the message. Hash functions that demonstrate this property are referred to as one-way hash functions.","title":"Hash Functions"},{"location":"consensus/architecture_overview/#digital_signatures","text":"Digital signatures enable the verification of a message. This verification ensures that a message originated from a particular node. Digital signatures are usually a public key, denoted by pki, used for verifying the signature of node i and a corresponding secret key, denoted by ski, used by node i for signing a message. This process is referred to as encryption. To prevent another node or a malicious node from impersonation, a node should not reveal this key. The purpose of the public key is to verify a signature generated by a secret key belonging to a node in the network. A digital signature scheme usually consists of three distinct parts: A key generation algorithm, A signing algorithm, and A verification algorithm. The key generation algorithm is used to generate a new set of key pairs. The main property required from a digital signature scheme is that of security. Without knowledge of a secret key, it is infeasible to find a string that passes the verification algorithm.","title":"Digital Signatures"},{"location":"consensus/architecture_overview/#event_system","text":"The concept of an event here is similar to traditional distributed algorithms where each event is defined as a unit of computation across a set of nodes. An event can be described as a tuple where pi is the node at which the event occurs, timestamp representing the exact time the event occurred, and information about the event. This definition is based on the more general formalism from distributed systems where each node of a distributed computation is a state machine and the computation causes a change of state.","title":"Event System"},{"location":"consensus/architecture_overview/#information_propagation","text":"Information propagation here deals with two main aspects: the first is about propagating information from a group of nodes to all the other nodes in the network. The other aspect is the propagation of information between two interacting nodes. The goal of information propagation is to provide every node in the network with the most recent information. This information propagation is the essence of communication in a distributed setting. Nodes in the network communicate by transmitting and receiving messages. A Message is therefore a unit of communication. A more general definition is that a message is just a finite sequence of bits. In a distributed environment where information is constantly flowing because of the interactions, there needs to be: An efficient mechanism for distributing this information i.e publish and An efficient mechanism to allow nodes to receive these specific kinds of information i.e subscribe. Specifically, in our scheme, we use a Pub-Sub pattern as the medium for information propagation.","title":"Information Propagation"},{"location":"consensus/architecture_overview/#voting","text":"The goal of voting is to aggregate individual preferences among a group into a single group ranking. Weighted voting is a voting method that affords certain nodes more privileges on the outcome of the vote than other nodes based on some specific context for which the voting system is deployed. Weighted voting is a form of social choice system originating from the domain of cooperative game theory [1]. They essentially model decision-making processes in which a set of voters make decisions about the outcome of an issue. Each voter is allocated a numeric weight, and the decision is carried out only if the sum of weights of voters in favor of it meets or exceeds some specific given threshold, called the quota.","title":"Voting"},{"location":"consensus/architecture_overview/#references","text":"[1] G. Chalkiadakis, E. Elkind, and M. Wooldridge, \u201cComputational aspects of cooperative game theory,\u201d Synthesis Lectures on Artificial Intelligence and Machine Learning, vol. 5, no. 6, pp. 1\u2013168, 2011.","title":"References:"},{"location":"consensus/history/","text":"In the blockchain world, consensus is a crucial mechanism that enables a decentralized network of nodes to agree on the state of the blockchain, ensuring that all nodes have the same version of the blockchain. There are currently many consensuses with their own solutions solving the trilemma problem. The most well-known consensus is Proof of Work (PoW) which uses computer power to solve a complex mathematical puzzle which is considered a fair mechanism to reach consensus but it still consumes a lot of energy and has low scalability. Proof of Stake (PoS) was created to address the limitations of PoW by introducing the concept of probabilistically creating the next block based on the amount of cryptocurrency staked. On the other hand, PoS still raises concerns about its centralization because the more tokens a particular entity has staked, the higher the chance of being chosen to create the next block. One of the great features of blockchain is that it can validate something even without a deep sense of what is being validated. This feature might bring to the witness whether this thing is the original truth or not. An obvious problem is a fraudulent smart contract deployed by a fraudster. There is nothing to do with this problem because the blockchain is open to any entities with any purposes, even malicious intent towards others. Therefore, any system or blockchain itself must have some mechanisms to validate the source of truth and incentivize honest behavior and give all entities some kind of confidence in the first place. In this paper, it is introduced as Proof of Reputation for a trustless reputation system. Proof of Reputation (PoR) is designed to leverage the reputation of participants in the network as a determinant of their influence on the consensus process. The idea behind PoR is to assign mining power or voting rights based on the reputation of the participants, which is a reflection of their past behavior, contributors, and trustworthiness within the network. Related Work # Reputation-Based Consensus Algorithms Historically, reputation systems have been known as a means of harnessing some form of reputation data. They function by facilitating the collection, aggregation, and distribution of data about a specific entity. This data can thereafter be used to characterize and predict that entity\u2019s future actions. Essentially, users within a network can decide who they will trust and to what extent by referring to reputation data. A reputation system, in addition to the foregoing, is a socially corrective mechanism, as the incentive of positive reputation and the disincentive of negative reputation will generally encourage good behavior in the long run. After a reputation system collects reputation data, it can be shared among users, who can then use it to evaluate other users before making decisions about intended or future interactions, without ever having previously interacted. Examples of the practical application of this system can be found on eCommerce websites like Amazon or eBay where reputation attributed to a seller is influenced by ratings through previous transactions. Another use case is in government where a country like China incentives the behavior of the citizens through a social credit score system. Earlier works proposed possibilities of applying a reputation-based model to distributed computing. The downside was that the approach was not completely decentralized. In the blockchain context, a reputation-based consensus mechanism works in a way where reputation serves as the incentive for good behavior and the node with the highest reputation gets to publish a new block. [1] proposed the Blockchain Reputation-Based Consensus (BRBC) mechanism in which a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Fair Proof of Reputation consensus (FPoR) [2] Current permissionless consensus protocols suffer centralization, unfairness and performance challenges. All PoW, PoS, DPoS can cause centralization issues, which is unfair to new participant nodes and contrary to the decentralization nature of blockchain. Besides, performance of permissionless consensus is still lower than permissioned consensus. FPoR is presented as a reputation-based consensus, which takes advantage of collateral, committee-based consensus, reputation-based node selection, PBFT, incentive mechanisms with reward and penalization. The FPoR consensus protocol includes following main steps: Collateral : Nodes who want to participate in consensus need collateral as security deposit, and only nodes with collateral can be candidate consensus nodes. Consensus group selection Candidate consensus nodes with collateral are randomly selected based on reputation to form a consensus group, who is responsible for the new block proposal. PBFT in consensus group: Nodes in the consensus group run PBFT protocol to verify and agree on the new block. Block propagation : The block verified by the consensus group will propagate to the blockchain network, and be known to all participant nodes. References: # [1] M. T. de Oliveira, L. H. Reis, D. S. Medeiros, R. C. Carrano, S. D. Olabarriaga, and D. M. Mattos, \u201cBlockchain reputation-based consensus: A scalable and resilient mechanism for distributed mistrusting applications,\u201d Computer Networks, vol. 179, p. 107367, 2020. [2] Tao Zhang, Zhigang Huang. \u201cFPoR: Fair proof-of-reputation consensus for blockchain\u201d","title":"History"},{"location":"consensus/history/#related_work","text":"Reputation-Based Consensus Algorithms Historically, reputation systems have been known as a means of harnessing some form of reputation data. They function by facilitating the collection, aggregation, and distribution of data about a specific entity. This data can thereafter be used to characterize and predict that entity\u2019s future actions. Essentially, users within a network can decide who they will trust and to what extent by referring to reputation data. A reputation system, in addition to the foregoing, is a socially corrective mechanism, as the incentive of positive reputation and the disincentive of negative reputation will generally encourage good behavior in the long run. After a reputation system collects reputation data, it can be shared among users, who can then use it to evaluate other users before making decisions about intended or future interactions, without ever having previously interacted. Examples of the practical application of this system can be found on eCommerce websites like Amazon or eBay where reputation attributed to a seller is influenced by ratings through previous transactions. Another use case is in government where a country like China incentives the behavior of the citizens through a social credit score system. Earlier works proposed possibilities of applying a reputation-based model to distributed computing. The downside was that the approach was not completely decentralized. In the blockchain context, a reputation-based consensus mechanism works in a way where reputation serves as the incentive for good behavior and the node with the highest reputation gets to publish a new block. [1] proposed the Blockchain Reputation-Based Consensus (BRBC) mechanism in which a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Fair Proof of Reputation consensus (FPoR) [2] Current permissionless consensus protocols suffer centralization, unfairness and performance challenges. All PoW, PoS, DPoS can cause centralization issues, which is unfair to new participant nodes and contrary to the decentralization nature of blockchain. Besides, performance of permissionless consensus is still lower than permissioned consensus. FPoR is presented as a reputation-based consensus, which takes advantage of collateral, committee-based consensus, reputation-based node selection, PBFT, incentive mechanisms with reward and penalization. The FPoR consensus protocol includes following main steps: Collateral : Nodes who want to participate in consensus need collateral as security deposit, and only nodes with collateral can be candidate consensus nodes. Consensus group selection Candidate consensus nodes with collateral are randomly selected based on reputation to form a consensus group, who is responsible for the new block proposal. PBFT in consensus group: Nodes in the consensus group run PBFT protocol to verify and agree on the new block. Block propagation : The block verified by the consensus group will propagate to the blockchain network, and be known to all participant nodes.","title":"Related Work"},{"location":"consensus/history/#references","text":"[1] M. T. de Oliveira, L. H. Reis, D. S. Medeiros, R. C. Carrano, S. D. Olabarriaga, and D. M. Mattos, \u201cBlockchain reputation-based consensus: A scalable and resilient mechanism for distributed mistrusting applications,\u201d Computer Networks, vol. 179, p. 107367, 2020. [2] Tao Zhang, Zhigang Huang. \u201cFPoR: Fair proof-of-reputation consensus for blockchain\u201d","title":"References:"},{"location":"consensus/por/","text":"PoR for A Trustless Reputation System # Assessment # Assessment can refer to a variety of activities, including evaluating the identity reputation, data validation, and authenticity of digital identities. The assessment process involves verifying the integrity and accuracy of data stored on the system, as well as ensuring that the network and its nodes are functioning as intended. Here is some major assessment in a trustless reputation system: Data validation : Verifying the accuracy and integrity of the data stored on the system, including data encoding, decoding and processing. Identity Verification : Verifying the authenticity of digital identities. Reputation Assessment : Evaluating the historical honest behaviors in the form of a reputation score. Consensus group # In order to prevent potential malicious behaviors and promote fairness and contribution to the system, consensus nodes in consensus group are randomly selected based on reputation, which means all consensus nodes have equal opportunity to engage in the consensus process regardless of its reputation. Probability of a consensus node selected in a consensus group depends on its current reputation Cu_R and cumulative reputation Cl_R which measures a node\u2019s continuous contribution to blockchain, and Cu_R is to promote fairness of nodes selected in consensus group. p(i) = (\u03b1 * Cl_R(i) + \u03b2 * Cu_R(i)) / (\u2211Cl_R(i) + \u2211Cu_R(i)) Where \u03b1+\u03b2=1,\u03b1>\u03b2>0 To avoid potential attacks and centralization, cumulative reputation and current reputation of a consensus group should meet the following requirements: Average of cumulative reputation of a consensus group 1/N * \u2211Cl_R(i) should be no less than average cumulative reputation of all candidate consensus nodes 1/n * \u2211Cl_R(i) 1/N * \u2211Cl_R(i) \u2265 1/n * \u2211Cl_R(j) where N is the number of nodes in the consensus group, n is the number of nodes in candidate consensus nodes pool. Average of current reputation of a consensus group 1/N * \u2211Cu_R(i) should be no less than average current reputation of all candidate consensus nodes 1/n * \u2211Cu_R (i) 1/N * \u2211Cu_R(i) \u2265 1/n * \u2211Cu_R(j) To balance performance and scalability, nodes of a consensus group should be no less than n if n \u2265 16 and 4 if n < 16 [4] To promote fairness, no participant node should create the majority of the blocks. The same node should not be selected in a consensus group to process two consecutive blocks. Besides, \u03b1 should be larger than \u03b2. PBFT in consensus group # PBFT has an advantage of performance and efficiency with a few nodes. To improve performance, the size of consensus group committees should be limited. The minimum number of nodes in the consensus group is confined to n (n \u226516). In the consensus group, PBFT is run to generate a new candidate block. Detailed procedures are as follows: In each consensus round, nodes in the consensus group elect a single leader node as block proposer. The leader node proposes a candidate block with a set of transactions. Then broadcast the candidate block to other nodes in the consensus group. When receiving the candidate block, other nodes in the consensus group validate and approve the block. If the candidate block gets supermajority approval (e.g., 2/3), it will be broadcasted to the entire blockchain network. Incentive # Reward is to economically incentive consensus nodes to behave honestly. The first incentive is block reward in forms of tangible asset (tokens), all consensus nodes selected in a consensus group successfully create a new block can get reward. And the second is reputation (intangible and non-transferable) which is changed over stages: Initial quick increase . When consensus nodes in consensus group behave honestly, both current reputation and cumulative reputation will update according to following rules: Rule 1: Cu_R = Cu_R + 2^\u03b3 * R_reward Rule 1: Cl_R = Cl_R + Cu_R In each round, current reputation value of honest node will add 2^\u03b3* R_reward cumulative reputation of honest nodes will add updated current reputation value. \uf067 is reputation factor which can be adjusted, R_reward is a fixed reward value for block generation. Slow increase in mid-life for quick reward of mature participants . To distinguish mature participants and new participants, \uf067 is adjusted to be smaller to make current reputation value increase slower. Prevention of over-control . To prevent potential centralization and promote fairness, consensus nodes are not allowed to propose two consecutive blocks. Thus, the increase of reputation in consensus nodes is relatively evenly. Punishment # Punishment mechanism is adopted to penalize bad behaviors. There are two kinds of punishment, including collateral and reputation, which can be on all nodes in the consensus group or the node with malicious behaviors. If nodes in the consensus group behave maliciously, and other honest nodes in the consensus group do not detect malicious behaviors, then all nodes in the consensus group should be penalized. If honest nodes in the consensus group detect malicious behaviors of malicious nodes, only nodes with malicious behaviors will be penalized. Malicious behaviors will have a negative impact on reputation Cl_R = Cl_R / 2. The cumulative reputation will be halved and current reputation will be reset to 0, as Cu_R = 0","title":"Proof of Reputation"},{"location":"consensus/por/#por_for_a_trustless_reputation_system","text":"","title":"PoR for A Trustless Reputation System"},{"location":"consensus/por/#assessment","text":"Assessment can refer to a variety of activities, including evaluating the identity reputation, data validation, and authenticity of digital identities. The assessment process involves verifying the integrity and accuracy of data stored on the system, as well as ensuring that the network and its nodes are functioning as intended. Here is some major assessment in a trustless reputation system: Data validation : Verifying the accuracy and integrity of the data stored on the system, including data encoding, decoding and processing. Identity Verification : Verifying the authenticity of digital identities. Reputation Assessment : Evaluating the historical honest behaviors in the form of a reputation score.","title":"Assessment"},{"location":"consensus/por/#consensus_group","text":"In order to prevent potential malicious behaviors and promote fairness and contribution to the system, consensus nodes in consensus group are randomly selected based on reputation, which means all consensus nodes have equal opportunity to engage in the consensus process regardless of its reputation. Probability of a consensus node selected in a consensus group depends on its current reputation Cu_R and cumulative reputation Cl_R which measures a node\u2019s continuous contribution to blockchain, and Cu_R is to promote fairness of nodes selected in consensus group. p(i) = (\u03b1 * Cl_R(i) + \u03b2 * Cu_R(i)) / (\u2211Cl_R(i) + \u2211Cu_R(i)) Where \u03b1+\u03b2=1,\u03b1>\u03b2>0 To avoid potential attacks and centralization, cumulative reputation and current reputation of a consensus group should meet the following requirements: Average of cumulative reputation of a consensus group 1/N * \u2211Cl_R(i) should be no less than average cumulative reputation of all candidate consensus nodes 1/n * \u2211Cl_R(i) 1/N * \u2211Cl_R(i) \u2265 1/n * \u2211Cl_R(j) where N is the number of nodes in the consensus group, n is the number of nodes in candidate consensus nodes pool. Average of current reputation of a consensus group 1/N * \u2211Cu_R(i) should be no less than average current reputation of all candidate consensus nodes 1/n * \u2211Cu_R (i) 1/N * \u2211Cu_R(i) \u2265 1/n * \u2211Cu_R(j) To balance performance and scalability, nodes of a consensus group should be no less than n if n \u2265 16 and 4 if n < 16 [4] To promote fairness, no participant node should create the majority of the blocks. The same node should not be selected in a consensus group to process two consecutive blocks. Besides, \u03b1 should be larger than \u03b2.","title":"Consensus group"},{"location":"consensus/por/#pbft_in_consensus_group","text":"PBFT has an advantage of performance and efficiency with a few nodes. To improve performance, the size of consensus group committees should be limited. The minimum number of nodes in the consensus group is confined to n (n \u226516). In the consensus group, PBFT is run to generate a new candidate block. Detailed procedures are as follows: In each consensus round, nodes in the consensus group elect a single leader node as block proposer. The leader node proposes a candidate block with a set of transactions. Then broadcast the candidate block to other nodes in the consensus group. When receiving the candidate block, other nodes in the consensus group validate and approve the block. If the candidate block gets supermajority approval (e.g., 2/3), it will be broadcasted to the entire blockchain network.","title":"PBFT in consensus group"},{"location":"consensus/por/#incentive","text":"Reward is to economically incentive consensus nodes to behave honestly. The first incentive is block reward in forms of tangible asset (tokens), all consensus nodes selected in a consensus group successfully create a new block can get reward. And the second is reputation (intangible and non-transferable) which is changed over stages: Initial quick increase . When consensus nodes in consensus group behave honestly, both current reputation and cumulative reputation will update according to following rules: Rule 1: Cu_R = Cu_R + 2^\u03b3 * R_reward Rule 1: Cl_R = Cl_R + Cu_R In each round, current reputation value of honest node will add 2^\u03b3* R_reward cumulative reputation of honest nodes will add updated current reputation value. \uf067 is reputation factor which can be adjusted, R_reward is a fixed reward value for block generation. Slow increase in mid-life for quick reward of mature participants . To distinguish mature participants and new participants, \uf067 is adjusted to be smaller to make current reputation value increase slower. Prevention of over-control . To prevent potential centralization and promote fairness, consensus nodes are not allowed to propose two consecutive blocks. Thus, the increase of reputation in consensus nodes is relatively evenly.","title":"Incentive"},{"location":"consensus/por/#punishment","text":"Punishment mechanism is adopted to penalize bad behaviors. There are two kinds of punishment, including collateral and reputation, which can be on all nodes in the consensus group or the node with malicious behaviors. If nodes in the consensus group behave maliciously, and other honest nodes in the consensus group do not detect malicious behaviors, then all nodes in the consensus group should be penalized. If honest nodes in the consensus group detect malicious behaviors of malicious nodes, only nodes with malicious behaviors will be penalized. Malicious behaviors will have a negative impact on reputation Cl_R = Cl_R / 2. The cumulative reputation will be halved and current reputation will be reset to 0, as Cu_R = 0","title":"Punishment"},{"location":"credit/credit_framework/","text":"Trustless Score Idealization To bridge the gap between traditional banking credit assessments and the decentralized world of cryptocurrencies, we can develop a comprehensive credit scoring framework for crypto addresses. This system aims to evaluate the creditworthiness of an address based on on-chain data, mirroring the factors banks consider when assessing individual credit scores. Here is the proposed framework for such system with the tech debt that will entail. The C.R.E.D.I.T. Score # The C.R.E.D.I.T. Score is a 100-point system that evaluates a crypto address across six key dimensions: Collateral (25 points) Repayment History (25 points) Engagement (15 points) Diversity of Assets (10 points) Identity Verification (15 points) Time in Network (10 points) 1. Collateral (25 Points) # Interpretation: This dimension assesses the financial strength of an address by evaluating the value and quality of assets that can be used as collateral. Indicators: Total Asset Value: The USD equivalent of all assets held in the address. (For prototype we can scan asset on BSC for now) Liquidity of Assets: Proportion of assets that are easily convertible to cash (e.g., stablecoins, top-tier cryptocurrencies). (When looking at Asset, we will give stablecoins a higher weight to this score following by bluechip coin ETH, BTC) Collateralization (LTV) Ratio: The ratio of collateral value to the amount borrowed on DeFi platforms. (Need to look at multiple lending protocol and scan their collateral token to define this) -> Tech Debt for Collateral Part : Asset scannning Total Asset Value on Chain Categorize on-chain asset type and define weight to them Understand the top on chain lending protocol and define their what token is being used as collateral token and determine their conversion rate (how much ETH is being deposit correspond to how much lama-ETH that got back from the protocal) This is protocol based and suspect that this is a case by case rate. 2. Repayment History (25 Points) # Interpretation: This dimension examines the address's history of fulfilling financial obligations, similar to payment history in traditional credit scoring. However, since most of lending protocols are using overcollaterize model, we can only fault them if we can detect liquidation and debt utilization as debt repayment is handle by protocol conversion rate (token-collaterized token) Indicators: Default Instances: Number of times the address has defaulted or been liquidated. Debt Utilization: The proportion of credit used relative to the total available credit. -> Tech Debt for Repayment Part : Find out what happened when an address is being liqudated on a lending-leveraging platform (for instance we can try getting liquidated on purpose on https://www.alpacafinance.org/ and see) Token - Collaterized Token Ratio and calculate how much money is being leveraged on yield farming or others usages. (Hard) 3. Engagement (15 Points) # Interpretation: Measures the address's active participation in the crypto ecosystem, indicating experience and reliability. Indicators: Active Days/Months: Number of days or months with at least one transaction. Transaction Frequency: Average number of transactions per week or month. Total Protocol Usage: Number of different DeFi platforms interacted with, especially lending and borrowing services. Healthy Smart Contract Interactions: Engagement with healthy smart contracts, showing advanced usage. Blacklist Contract Interactions: Engagement with money laundering/privacy smart contracts (this can be use as a minus point) Compromised Contract Interactions: Engagement with compromised smart contracts (this can be use as a minus point) -> Tech Debt for Engagement Part : Find all of the popular lending and borrowing Defi platform for each of the network that we aim to score on Hard code smart contract address ??? How should we black list smart contract ?? How compromised smart contract will be updated in the system. 4. Diversification Risk - Behavior Framework Scoring !! (10 Points) # Interpretation: Assesses the address's asset diversification, reflecting sound investment strategies and risk management. Indicators: Asset Classes: Variety of asset types held (e.g., cryptocurrencies, tokens, NFTs). Cross-Chain Holdings: Assets held across multiple blockchain networks. -> Tech Debt for Diversity Part : This is the hardest to give a hard code rule for !!! even though it is easy to implement 5. Identity Verification (15 Points) # Interpretation: Establishes the credibility of the address through identity proofs and reputation systems. Indicators: KYC/AML Compliance: Completion of Know Your Customer (KYC) and Anti-Money Laundering (AML) checks on reputable platforms. Decentralized Identifiers (DIDs): Ownership of verified decentralized identities like ENS domains or Lens Protocol profiles. Social Proofs: Verification through social platforms linked to the address. -> Tech Debt for Identity Part : All this layer is already a tech debt in module planning Allocating weight for each of the identitity layers 6. Time in Network (10 Points) # Interpretation: Considers the longevity and consistency of the address's activity in the blockchain network. Indicators: Account Age: Duration since the first recorded transaction. Historical Participation: Early involvement in significant network events or protocols. -> Tech Debt for Time Part : Age is easy to do Historical Participation entails we know what has,is and will happen on chain ( What airdrops, genesis event, reward for testing protocal, ....) Total Score: 100 Points # Each dimension contributes to a comprehensive view of the address's creditworthiness, similar to how traditional banks assess individual credit scores. Next step # After agreeing on the above idealization, tasks can be handle to each team members in Data/Computation team to start on the technical debt described. Further study: # AI and Machine Learning Framework for Robust Sybil Resistance Proof of Innocence Program References: # Trustalab Docs","title":"C.R.E.D.I.T Score"},{"location":"credit/credit_framework/#the_credit_score","text":"The C.R.E.D.I.T. Score is a 100-point system that evaluates a crypto address across six key dimensions: Collateral (25 points) Repayment History (25 points) Engagement (15 points) Diversity of Assets (10 points) Identity Verification (15 points) Time in Network (10 points)","title":"The C.R.E.D.I.T. Score"},{"location":"credit/credit_framework/#1_collateral_25_points","text":"Interpretation: This dimension assesses the financial strength of an address by evaluating the value and quality of assets that can be used as collateral. Indicators: Total Asset Value: The USD equivalent of all assets held in the address. (For prototype we can scan asset on BSC for now) Liquidity of Assets: Proportion of assets that are easily convertible to cash (e.g., stablecoins, top-tier cryptocurrencies). (When looking at Asset, we will give stablecoins a higher weight to this score following by bluechip coin ETH, BTC) Collateralization (LTV) Ratio: The ratio of collateral value to the amount borrowed on DeFi platforms. (Need to look at multiple lending protocol and scan their collateral token to define this) -> Tech Debt for Collateral Part : Asset scannning Total Asset Value on Chain Categorize on-chain asset type and define weight to them Understand the top on chain lending protocol and define their what token is being used as collateral token and determine their conversion rate (how much ETH is being deposit correspond to how much lama-ETH that got back from the protocal) This is protocol based and suspect that this is a case by case rate.","title":"1. Collateral (25 Points)"},{"location":"credit/credit_framework/#2_repayment_history_25_points","text":"Interpretation: This dimension examines the address's history of fulfilling financial obligations, similar to payment history in traditional credit scoring. However, since most of lending protocols are using overcollaterize model, we can only fault them if we can detect liquidation and debt utilization as debt repayment is handle by protocol conversion rate (token-collaterized token) Indicators: Default Instances: Number of times the address has defaulted or been liquidated. Debt Utilization: The proportion of credit used relative to the total available credit. -> Tech Debt for Repayment Part : Find out what happened when an address is being liqudated on a lending-leveraging platform (for instance we can try getting liquidated on purpose on https://www.alpacafinance.org/ and see) Token - Collaterized Token Ratio and calculate how much money is being leveraged on yield farming or others usages. (Hard)","title":"2. Repayment History (25 Points)"},{"location":"credit/credit_framework/#3_engagement_15_points","text":"Interpretation: Measures the address's active participation in the crypto ecosystem, indicating experience and reliability. Indicators: Active Days/Months: Number of days or months with at least one transaction. Transaction Frequency: Average number of transactions per week or month. Total Protocol Usage: Number of different DeFi platforms interacted with, especially lending and borrowing services. Healthy Smart Contract Interactions: Engagement with healthy smart contracts, showing advanced usage. Blacklist Contract Interactions: Engagement with money laundering/privacy smart contracts (this can be use as a minus point) Compromised Contract Interactions: Engagement with compromised smart contracts (this can be use as a minus point) -> Tech Debt for Engagement Part : Find all of the popular lending and borrowing Defi platform for each of the network that we aim to score on Hard code smart contract address ??? How should we black list smart contract ?? How compromised smart contract will be updated in the system.","title":"3. Engagement (15 Points)"},{"location":"credit/credit_framework/#4_diversification_risk_-_behavior_framework_scoring_10_points","text":"Interpretation: Assesses the address's asset diversification, reflecting sound investment strategies and risk management. Indicators: Asset Classes: Variety of asset types held (e.g., cryptocurrencies, tokens, NFTs). Cross-Chain Holdings: Assets held across multiple blockchain networks. -> Tech Debt for Diversity Part : This is the hardest to give a hard code rule for !!! even though it is easy to implement","title":"4. Diversification Risk - Behavior Framework Scoring !! (10 Points)"},{"location":"credit/credit_framework/#5_identity_verification_15_points","text":"Interpretation: Establishes the credibility of the address through identity proofs and reputation systems. Indicators: KYC/AML Compliance: Completion of Know Your Customer (KYC) and Anti-Money Laundering (AML) checks on reputable platforms. Decentralized Identifiers (DIDs): Ownership of verified decentralized identities like ENS domains or Lens Protocol profiles. Social Proofs: Verification through social platforms linked to the address. -> Tech Debt for Identity Part : All this layer is already a tech debt in module planning Allocating weight for each of the identitity layers","title":"5. Identity Verification (15 Points)"},{"location":"credit/credit_framework/#6_time_in_network_10_points","text":"Interpretation: Considers the longevity and consistency of the address's activity in the blockchain network. Indicators: Account Age: Duration since the first recorded transaction. Historical Participation: Early involvement in significant network events or protocols. -> Tech Debt for Time Part : Age is easy to do Historical Participation entails we know what has,is and will happen on chain ( What airdrops, genesis event, reward for testing protocal, ....)","title":"6. Time in Network (10 Points)"},{"location":"credit/credit_framework/#total_score_100_points","text":"Each dimension contributes to a comprehensive view of the address's creditworthiness, similar to how traditional banks assess individual credit scores.","title":"Total Score: 100 Points"},{"location":"credit/credit_framework/#next_step","text":"After agreeing on the above idealization, tasks can be handle to each team members in Data/Computation team to start on the technical debt described.","title":"Next step"},{"location":"credit/credit_framework/#further_study","text":"AI and Machine Learning Framework for Robust Sybil Resistance Proof of Innocence Program","title":"Further study:"},{"location":"credit/credit_framework/#references","text":"Trustalab Docs","title":"References:"}]}