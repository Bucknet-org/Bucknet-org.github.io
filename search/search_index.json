{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Bucknet \u00b6 A pioneer trustless reputation system for money markets","title":"Introduction"},{"location":"#welcome-to-bucknet","text":"A pioneer trustless reputation system for money markets","title":"Welcome to Bucknet"},{"location":"consensus/architecture_overview/","text":"Considerations \u00b6 Here are some major considerations when it comes to design PoR for a trustless reputation system: Reputation Score Calculation : Each participant (data provider, validator, or user, etc.) in the network is assigned a reputation score. This score could be based on various factors, such as historical behavior, uptime, contributions to the network, security measures implemented, and feedback from other network participants. The mechanism for calculating reputation must be carefully designed to prevent manipulation and ensure that it accurately reflects each participant's trustworthiness and contributions to the network. Identity Verification : To prevent sybil attacks (where a single user creates multiple identities), participants must undergo a thorough identity verification process. This ensures that the reputation score is tied to a real-world entity. On the other hand, this might raise privacy concerns. Validator Selection : When it comes time to create new blocks, the network selects validators based on their reputation scores. Nodes with higher reputations have a greater chance of being chosen to participate in the consensus process. And a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Block Creation and Validation : Once selected, validators are responsible for checking transactions, bundling them into blocks, and proposing these blocks to the network. Other nodes with high reputations then verify the proposed block. Consensus Finality : The block is considered valid and is added to the blockchain after a certain percentage of the network's reputational power has confirmed its validity. This reduces the likelihood of forks and ensures faster transaction finality. Reputation Updates : The reputation scores of participants are continuously updated based on their ongoing behavior and contributions. Malicious actors or those failing to maintain network standards would see their reputation scores decrease, reducing their influence in the consensus process. Incentives and Penalties : Participants are incentivized to maintain a good reputation to earn block rewards and transaction fees. Conversely, if a participant acts maliciously or fails to perform their duties, they may be penalized through reduced reputation scores or exclusion from the consensus process. Enhanced Security : By tying the consensus power to a measurable and adjustable reputation score, PoR aims to enhance the security of the network. It becomes more costly for attackers to build a significant enough reputation to disrupt the network compared to simply acquiring hash power or coins for a PoW or PoS system. Network Governance : PoR can also be integrated with on-chain governance mechanisms, allowing participants to vote on network upgrades and changes based on their reputation scores. Transparency and Auditability : The reputation system must be transparent and auditable to ensure trust in the consensus mechanism. All participants should be able to understand how reputation scores are calculated and how they affect the consensus process. Cryptographic Primitives \u00b6 Hash Functions \u00b6 We use very secure hash functions generated with the Elliptic Curve Cryptography to generate all types of encryption needed. This method is both efficient and performant. It takes any arbitrarily long string and converts it to a fixed-length string. The main characteristics of this hash function is that for a given message, it is easy to compute the hash; but given the hash, it is difficult to compute the message. Hash functions that demonstrate this property are referred to as one-way hash functions. Digital Signatures \u00b6 Digital signatures enable the verification of a message. This verification ensures that a message originated from a particular node. Digital signatures are usually a public key, denoted by pki, used for verifying the signature of node i and a corresponding secret key, denoted by ski, used by node i for signing a message. This process is referred to as encryption. To prevent another node or a malicious node from impersonation, a node should not reveal this key. The purpose of the public key is to verify a signature generated by a secret key belonging to a node in the network. A digital signature scheme usually consists of three distinct parts: A key generation algorithm, A signing algorithm, and A verification algorithm. The key generation algorithm is used to generate a new set of key pairs. The main property required from a digital signature scheme is that of security. Without knowledge of a secret key, it is infeasible to find a string that passes the verification algorithm. Event System \u00b6 The concept of an event here is similar to traditional distributed algorithms where each event is defined as a unit of computation across a set of nodes. An event can be described as a tuple where pi is the node at which the event occurs, timestamp representing the exact time the event occurred, and information about the event. This definition is based on the more general formalism from distributed systems where each node of a distributed computation is a state machine and the computation causes a change of state. Information Propagation \u00b6 Information propagation here deals with two main aspects: the first is about propagating information from a group of nodes to all the other nodes in the network. The other aspect is the propagation of information between two interacting nodes. The goal of information propagation is to provide every node in the network with the most recent information. This information propagation is the essence of communication in a distributed setting. Nodes in the network communicate by transmitting and receiving messages. A Message is therefore a unit of communication. A more general definition is that a message is just a finite sequence of bits. In a distributed environment where information is constantly flowing because of the interactions, there needs to be: An efficient mechanism for distributing this information i.e publish and An efficient mechanism to allow nodes to receive these specific kinds of information i.e subscribe. Specifically, in our scheme, we use a Pub-Sub pattern as the medium for information propagation. Voting \u00b6 The goal of voting is to aggregate individual preferences among a group into a single group ranking. Weighted voting is a voting method that affords certain nodes more privileges on the outcome of the vote than other nodes based on some specific context for which the voting system is deployed. Weighted voting is a form of social choice system originating from the domain of cooperative game theory [1]. They essentially model decision-making processes in which a set of voters make decisions about the outcome of an issue. Each voter is allocated a numeric weight, and the decision is carried out only if the sum of weights of voters in favor of it meets or exceeds some specific given threshold, called the quota. References: \u00b6 [1] G. Chalkiadakis, E. Elkind, and M. Wooldridge, \u201cComputational aspects of cooperative game theory,\u201d Synthesis Lectures on Artificial Intelligence and Machine Learning, vol. 5, no. 6, pp. 1\u2013168, 2011.","title":"Architecture Overview"},{"location":"consensus/architecture_overview/#considerations","text":"Here are some major considerations when it comes to design PoR for a trustless reputation system: Reputation Score Calculation : Each participant (data provider, validator, or user, etc.) in the network is assigned a reputation score. This score could be based on various factors, such as historical behavior, uptime, contributions to the network, security measures implemented, and feedback from other network participants. The mechanism for calculating reputation must be carefully designed to prevent manipulation and ensure that it accurately reflects each participant's trustworthiness and contributions to the network. Identity Verification : To prevent sybil attacks (where a single user creates multiple identities), participants must undergo a thorough identity verification process. This ensures that the reputation score is tied to a real-world entity. On the other hand, this might raise privacy concerns. Validator Selection : When it comes time to create new blocks, the network selects validators based on their reputation scores. Nodes with higher reputations have a greater chance of being chosen to participate in the consensus process. And a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Block Creation and Validation : Once selected, validators are responsible for checking transactions, bundling them into blocks, and proposing these blocks to the network. Other nodes with high reputations then verify the proposed block. Consensus Finality : The block is considered valid and is added to the blockchain after a certain percentage of the network's reputational power has confirmed its validity. This reduces the likelihood of forks and ensures faster transaction finality. Reputation Updates : The reputation scores of participants are continuously updated based on their ongoing behavior and contributions. Malicious actors or those failing to maintain network standards would see their reputation scores decrease, reducing their influence in the consensus process. Incentives and Penalties : Participants are incentivized to maintain a good reputation to earn block rewards and transaction fees. Conversely, if a participant acts maliciously or fails to perform their duties, they may be penalized through reduced reputation scores or exclusion from the consensus process. Enhanced Security : By tying the consensus power to a measurable and adjustable reputation score, PoR aims to enhance the security of the network. It becomes more costly for attackers to build a significant enough reputation to disrupt the network compared to simply acquiring hash power or coins for a PoW or PoS system. Network Governance : PoR can also be integrated with on-chain governance mechanisms, allowing participants to vote on network upgrades and changes based on their reputation scores. Transparency and Auditability : The reputation system must be transparent and auditable to ensure trust in the consensus mechanism. All participants should be able to understand how reputation scores are calculated and how they affect the consensus process.","title":"Considerations"},{"location":"consensus/architecture_overview/#cryptographic-primitives","text":"","title":"Cryptographic Primitives"},{"location":"consensus/architecture_overview/#hash-functions","text":"We use very secure hash functions generated with the Elliptic Curve Cryptography to generate all types of encryption needed. This method is both efficient and performant. It takes any arbitrarily long string and converts it to a fixed-length string. The main characteristics of this hash function is that for a given message, it is easy to compute the hash; but given the hash, it is difficult to compute the message. Hash functions that demonstrate this property are referred to as one-way hash functions.","title":"Hash Functions"},{"location":"consensus/architecture_overview/#digital-signatures","text":"Digital signatures enable the verification of a message. This verification ensures that a message originated from a particular node. Digital signatures are usually a public key, denoted by pki, used for verifying the signature of node i and a corresponding secret key, denoted by ski, used by node i for signing a message. This process is referred to as encryption. To prevent another node or a malicious node from impersonation, a node should not reveal this key. The purpose of the public key is to verify a signature generated by a secret key belonging to a node in the network. A digital signature scheme usually consists of three distinct parts: A key generation algorithm, A signing algorithm, and A verification algorithm. The key generation algorithm is used to generate a new set of key pairs. The main property required from a digital signature scheme is that of security. Without knowledge of a secret key, it is infeasible to find a string that passes the verification algorithm.","title":"Digital Signatures"},{"location":"consensus/architecture_overview/#event-system","text":"The concept of an event here is similar to traditional distributed algorithms where each event is defined as a unit of computation across a set of nodes. An event can be described as a tuple where pi is the node at which the event occurs, timestamp representing the exact time the event occurred, and information about the event. This definition is based on the more general formalism from distributed systems where each node of a distributed computation is a state machine and the computation causes a change of state.","title":"Event System"},{"location":"consensus/architecture_overview/#information-propagation","text":"Information propagation here deals with two main aspects: the first is about propagating information from a group of nodes to all the other nodes in the network. The other aspect is the propagation of information between two interacting nodes. The goal of information propagation is to provide every node in the network with the most recent information. This information propagation is the essence of communication in a distributed setting. Nodes in the network communicate by transmitting and receiving messages. A Message is therefore a unit of communication. A more general definition is that a message is just a finite sequence of bits. In a distributed environment where information is constantly flowing because of the interactions, there needs to be: An efficient mechanism for distributing this information i.e publish and An efficient mechanism to allow nodes to receive these specific kinds of information i.e subscribe. Specifically, in our scheme, we use a Pub-Sub pattern as the medium for information propagation.","title":"Information Propagation"},{"location":"consensus/architecture_overview/#voting","text":"The goal of voting is to aggregate individual preferences among a group into a single group ranking. Weighted voting is a voting method that affords certain nodes more privileges on the outcome of the vote than other nodes based on some specific context for which the voting system is deployed. Weighted voting is a form of social choice system originating from the domain of cooperative game theory [1]. They essentially model decision-making processes in which a set of voters make decisions about the outcome of an issue. Each voter is allocated a numeric weight, and the decision is carried out only if the sum of weights of voters in favor of it meets or exceeds some specific given threshold, called the quota.","title":"Voting"},{"location":"consensus/architecture_overview/#references","text":"[1] G. Chalkiadakis, E. Elkind, and M. Wooldridge, \u201cComputational aspects of cooperative game theory,\u201d Synthesis Lectures on Artificial Intelligence and Machine Learning, vol. 5, no. 6, pp. 1\u2013168, 2011.","title":"References:"},{"location":"consensus/history/","text":"In the blockchain world, consensus is a crucial mechanism that enables a decentralized network of nodes to agree on the state of the blockchain, ensuring that all nodes have the same version of the blockchain. There are currently many consensuses with their own solutions solving the trilemma problem. The most well-known consensus is Proof of Work (PoW) which uses computer power to solve a complex mathematical puzzle which is considered a fair mechanism to reach consensus but it still consumes a lot of energy and has low scalability. Proof of Stake (PoS) was created to address the limitations of PoW by introducing the concept of probabilistically creating the next block based on the amount of cryptocurrency staked. On the other hand, PoS still raises concerns about its centralization because the more tokens a particular entity has staked, the higher the chance of being chosen to create the next block. One of the great features of blockchain is that it can validate something even without a deep sense of what is being validated. This feature might bring to the witness whether this thing is the original truth or not. An obvious problem is a fraudulent smart contract deployed by a fraudster. There is nothing to do with this problem because the blockchain is open to any entities with any purposes, even malicious intent towards others. Therefore, any system or blockchain itself must have some mechanisms to validate the source of truth and incentivize honest behavior and give all entities some kind of confidence in the first place. In this paper, it is introduced as Proof of Reputation for a trustless reputation system. Proof of Reputation (PoR) is designed to leverage the reputation of participants in the network as a determinant of their influence on the consensus process. The idea behind PoR is to assign mining power or voting rights based on the reputation of the participants, which is a reflection of their past behavior, contributors, and trustworthiness within the network. Related Work \u00b6 Reputation-Based Consensus Algorithms Historically, reputation systems have been known as a means of harnessing some form of reputation data. They function by facilitating the collection, aggregation, and distribution of data about a specific entity. This data can thereafter be used to characterize and predict that entity\u2019s future actions. Essentially, users within a network can decide who they will trust and to what extent by referring to reputation data. A reputation system, in addition to the foregoing, is a socially corrective mechanism, as the incentive of positive reputation and the disincentive of negative reputation will generally encourage good behavior in the long run. After a reputation system collects reputation data, it can be shared among users, who can then use it to evaluate other users before making decisions about intended or future interactions, without ever having previously interacted. Examples of the practical application of this system can be found on eCommerce websites like Amazon or eBay where reputation attributed to a seller is influenced by ratings through previous transactions. Another use case is in government where a country like China incentives the behavior of the citizens through a social credit score system. Earlier works proposed possibilities of applying a reputation-based model to distributed computing. The downside was that the approach was not completely decentralized. In the blockchain context, a reputation-based consensus mechanism works in a way where reputation serves as the incentive for good behavior and the node with the highest reputation gets to publish a new block. [1] proposed the Blockchain Reputation-Based Consensus (BRBC) mechanism in which a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Fair Proof of Reputation consensus (FPoR) [2] Current permissionless consensus protocols suffer centralization, unfairness and performance challenges. All PoW, PoS, DPoS can cause centralization issues, which is unfair to new participant nodes and contrary to the decentralization nature of blockchain. Besides, performance of permissionless consensus is still lower than permissioned consensus. FPoR is presented as a reputation-based consensus, which takes advantage of collateral, committee-based consensus, reputation-based node selection, PBFT, incentive mechanisms with reward and penalization. The FPoR consensus protocol includes following main steps: Collateral : Nodes who want to participate in consensus need collateral as security deposit, and only nodes with collateral can be candidate consensus nodes. Consensus group selection Candidate consensus nodes with collateral are randomly selected based on reputation to form a consensus group, who is responsible for the new block proposal. PBFT in consensus group: Nodes in the consensus group run PBFT protocol to verify and agree on the new block. Block propagation : The block verified by the consensus group will propagate to the blockchain network, and be known to all participant nodes. References: \u00b6 [1] M. T. de Oliveira, L. H. Reis, D. S. Medeiros, R. C. Carrano, S. D. Olabarriaga, and D. M. Mattos, \u201cBlockchain reputation-based consensus: A scalable and resilient mechanism for distributed mistrusting applications,\u201d Computer Networks, vol. 179, p. 107367, 2020. [2] Tao Zhang, Zhigang Huang. \u201cFPoR: Fair proof-of-reputation consensus for blockchain\u201d","title":"History"},{"location":"consensus/history/#related-work","text":"Reputation-Based Consensus Algorithms Historically, reputation systems have been known as a means of harnessing some form of reputation data. They function by facilitating the collection, aggregation, and distribution of data about a specific entity. This data can thereafter be used to characterize and predict that entity\u2019s future actions. Essentially, users within a network can decide who they will trust and to what extent by referring to reputation data. A reputation system, in addition to the foregoing, is a socially corrective mechanism, as the incentive of positive reputation and the disincentive of negative reputation will generally encourage good behavior in the long run. After a reputation system collects reputation data, it can be shared among users, who can then use it to evaluate other users before making decisions about intended or future interactions, without ever having previously interacted. Examples of the practical application of this system can be found on eCommerce websites like Amazon or eBay where reputation attributed to a seller is influenced by ratings through previous transactions. Another use case is in government where a country like China incentives the behavior of the citizens through a social credit score system. Earlier works proposed possibilities of applying a reputation-based model to distributed computing. The downside was that the approach was not completely decentralized. In the blockchain context, a reputation-based consensus mechanism works in a way where reputation serves as the incentive for good behavior and the node with the highest reputation gets to publish a new block. [1] proposed the Blockchain Reputation-Based Consensus (BRBC) mechanism in which a node in the network must have a reputation score higher than a set threshold to be able to publish a new block. Also, a judge is randomly selected that is responsible for updating node reputation values. However, none of these addresses the behavior of a node on a transactional basis as it interacts with other nodes in the network. Fair Proof of Reputation consensus (FPoR) [2] Current permissionless consensus protocols suffer centralization, unfairness and performance challenges. All PoW, PoS, DPoS can cause centralization issues, which is unfair to new participant nodes and contrary to the decentralization nature of blockchain. Besides, performance of permissionless consensus is still lower than permissioned consensus. FPoR is presented as a reputation-based consensus, which takes advantage of collateral, committee-based consensus, reputation-based node selection, PBFT, incentive mechanisms with reward and penalization. The FPoR consensus protocol includes following main steps: Collateral : Nodes who want to participate in consensus need collateral as security deposit, and only nodes with collateral can be candidate consensus nodes. Consensus group selection Candidate consensus nodes with collateral are randomly selected based on reputation to form a consensus group, who is responsible for the new block proposal. PBFT in consensus group: Nodes in the consensus group run PBFT protocol to verify and agree on the new block. Block propagation : The block verified by the consensus group will propagate to the blockchain network, and be known to all participant nodes.","title":"Related Work"},{"location":"consensus/history/#references","text":"[1] M. T. de Oliveira, L. H. Reis, D. S. Medeiros, R. C. Carrano, S. D. Olabarriaga, and D. M. Mattos, \u201cBlockchain reputation-based consensus: A scalable and resilient mechanism for distributed mistrusting applications,\u201d Computer Networks, vol. 179, p. 107367, 2020. [2] Tao Zhang, Zhigang Huang. \u201cFPoR: Fair proof-of-reputation consensus for blockchain\u201d","title":"References:"},{"location":"consensus/por/","text":"PoR for A Trustless Reputation System \u00b6 Assessment \u00b6 Assessment can refer to a variety of activities, including evaluating the identity reputation, data validation, and authenticity of digital identities. The assessment process involves verifying the integrity and accuracy of data stored on the system, as well as ensuring that the network and its nodes are functioning as intended. Here is some major assessment in a trustless reputation system: Data validation : Verifying the accuracy and integrity of the data stored on the system, including data encoding, decoding and processing. Identity Verification : Verifying the authenticity of digital identities. Reputation Assessment : Evaluating the historical honest behaviors in the form of a reputation score. Consensus group \u00b6 In order to prevent potential malicious behaviors and promote fairness and contribution to the system, consensus nodes in consensus group are randomly selected based on reputation, which means all consensus nodes have equal opportunity to engage in the consensus process regardless of its reputation. Probability of a consensus node selected in a consensus group depends on its current reputation Cu_R and cumulative reputation Cl_R which measures a node\u2019s continuous contribution to blockchain, and Cu_R is to promote fairness of nodes selected in consensus group. p(i) = (\u03b1 * Cl_R(i) + \u03b2 * Cu_R(i)) / (\u2211Cl_R(i) + \u2211Cu_R(i)) Where \u03b1+\u03b2=1,\u03b1>\u03b2>0 To avoid potential attacks and centralization, cumulative reputation and current reputation of a consensus group should meet the following requirements: Average of cumulative reputation of a consensus group 1/N * \u2211Cl_R(i) should be no less than average cumulative reputation of all candidate consensus nodes 1/n * \u2211Cl_R(i) 1/N * \u2211Cl_R(i) \u2265 1/n * \u2211Cl_R(j) where N is the number of nodes in the consensus group, n is the number of nodes in candidate consensus nodes pool. Average of current reputation of a consensus group 1/N * \u2211Cu_R(i) should be no less than average current reputation of all candidate consensus nodes 1/n * \u2211Cu_R (i) 1/N * \u2211Cu_R(i) \u2265 1/n * \u2211Cu_R(j) To balance performance and scalability, nodes of a consensus group should be no less than n if n \u2265 16 and 4 if n < 16 [4] To promote fairness, no participant node should create the majority of the blocks. The same node should not be selected in a consensus group to process two consecutive blocks. Besides, \u03b1 should be larger than \u03b2. PBFT in consensus group \u00b6 PBFT has an advantage of performance and efficiency with a few nodes. To improve performance, the size of consensus group committees should be limited. The minimum number of nodes in the consensus group is confined to n (n \u226516). In the consensus group, PBFT is run to generate a new candidate block. Detailed procedures are as follows: In each consensus round, nodes in the consensus group elect a single leader node as block proposer. The leader node proposes a candidate block with a set of transactions. Then broadcast the candidate block to other nodes in the consensus group. When receiving the candidate block, other nodes in the consensus group validate and approve the block. If the candidate block gets supermajority approval (e.g., 2/3), it will be broadcasted to the entire blockchain network. Incentive \u00b6 Reward is to economically incentive consensus nodes to behave honestly. The first incentive is block reward in forms of tangible asset (tokens), all consensus nodes selected in a consensus group successfully create a new block can get reward. And the second is reputation (intangible and non-transferable) which is changed over stages: Initial quick increase . When consensus nodes in consensus group behave honestly, both current reputation and cumulative reputation will update according to following rules: Rule 1: Cu_R = Cu_R + 2^\u03b3 * R_reward Rule 1: Cl_R = Cl_R + Cu_R In each round, current reputation value of honest node will add 2^\u03b3* R_reward cumulative reputation of honest nodes will add updated current reputation value. \uf067 is reputation factor which can be adjusted, R_reward is a fixed reward value for block generation. Slow increase in mid-life for quick reward of mature participants . To distinguish mature participants and new participants, \uf067 is adjusted to be smaller to make current reputation value increase slower. Prevention of over-control . To prevent potential centralization and promote fairness, consensus nodes are not allowed to propose two consecutive blocks. Thus, the increase of reputation in consensus nodes is relatively evenly. Punishment \u00b6 Punishment mechanism is adopted to penalize bad behaviors. There are two kinds of punishment, including collateral and reputation, which can be on all nodes in the consensus group or the node with malicious behaviors. If nodes in the consensus group behave maliciously, and other honest nodes in the consensus group do not detect malicious behaviors, then all nodes in the consensus group should be penalized. If honest nodes in the consensus group detect malicious behaviors of malicious nodes, only nodes with malicious behaviors will be penalized. Malicious behaviors will have a negative impact on reputation Cl_R = Cl_R / 2. The cumulative reputation will be halved and current reputation will be reset to 0, as Cu_R = 0","title":"Proof of Reputation"},{"location":"consensus/por/#por-for-a-trustless-reputation-system","text":"","title":"PoR for A Trustless Reputation System"},{"location":"consensus/por/#assessment","text":"Assessment can refer to a variety of activities, including evaluating the identity reputation, data validation, and authenticity of digital identities. The assessment process involves verifying the integrity and accuracy of data stored on the system, as well as ensuring that the network and its nodes are functioning as intended. Here is some major assessment in a trustless reputation system: Data validation : Verifying the accuracy and integrity of the data stored on the system, including data encoding, decoding and processing. Identity Verification : Verifying the authenticity of digital identities. Reputation Assessment : Evaluating the historical honest behaviors in the form of a reputation score.","title":"Assessment"},{"location":"consensus/por/#consensus-group","text":"In order to prevent potential malicious behaviors and promote fairness and contribution to the system, consensus nodes in consensus group are randomly selected based on reputation, which means all consensus nodes have equal opportunity to engage in the consensus process regardless of its reputation. Probability of a consensus node selected in a consensus group depends on its current reputation Cu_R and cumulative reputation Cl_R which measures a node\u2019s continuous contribution to blockchain, and Cu_R is to promote fairness of nodes selected in consensus group. p(i) = (\u03b1 * Cl_R(i) + \u03b2 * Cu_R(i)) / (\u2211Cl_R(i) + \u2211Cu_R(i)) Where \u03b1+\u03b2=1,\u03b1>\u03b2>0 To avoid potential attacks and centralization, cumulative reputation and current reputation of a consensus group should meet the following requirements: Average of cumulative reputation of a consensus group 1/N * \u2211Cl_R(i) should be no less than average cumulative reputation of all candidate consensus nodes 1/n * \u2211Cl_R(i) 1/N * \u2211Cl_R(i) \u2265 1/n * \u2211Cl_R(j) where N is the number of nodes in the consensus group, n is the number of nodes in candidate consensus nodes pool. Average of current reputation of a consensus group 1/N * \u2211Cu_R(i) should be no less than average current reputation of all candidate consensus nodes 1/n * \u2211Cu_R (i) 1/N * \u2211Cu_R(i) \u2265 1/n * \u2211Cu_R(j) To balance performance and scalability, nodes of a consensus group should be no less than n if n \u2265 16 and 4 if n < 16 [4] To promote fairness, no participant node should create the majority of the blocks. The same node should not be selected in a consensus group to process two consecutive blocks. Besides, \u03b1 should be larger than \u03b2.","title":"Consensus group"},{"location":"consensus/por/#pbft-in-consensus-group","text":"PBFT has an advantage of performance and efficiency with a few nodes. To improve performance, the size of consensus group committees should be limited. The minimum number of nodes in the consensus group is confined to n (n \u226516). In the consensus group, PBFT is run to generate a new candidate block. Detailed procedures are as follows: In each consensus round, nodes in the consensus group elect a single leader node as block proposer. The leader node proposes a candidate block with a set of transactions. Then broadcast the candidate block to other nodes in the consensus group. When receiving the candidate block, other nodes in the consensus group validate and approve the block. If the candidate block gets supermajority approval (e.g., 2/3), it will be broadcasted to the entire blockchain network.","title":"PBFT in consensus group"},{"location":"consensus/por/#incentive","text":"Reward is to economically incentive consensus nodes to behave honestly. The first incentive is block reward in forms of tangible asset (tokens), all consensus nodes selected in a consensus group successfully create a new block can get reward. And the second is reputation (intangible and non-transferable) which is changed over stages: Initial quick increase . When consensus nodes in consensus group behave honestly, both current reputation and cumulative reputation will update according to following rules: Rule 1: Cu_R = Cu_R + 2^\u03b3 * R_reward Rule 1: Cl_R = Cl_R + Cu_R In each round, current reputation value of honest node will add 2^\u03b3* R_reward cumulative reputation of honest nodes will add updated current reputation value. \uf067 is reputation factor which can be adjusted, R_reward is a fixed reward value for block generation. Slow increase in mid-life for quick reward of mature participants . To distinguish mature participants and new participants, \uf067 is adjusted to be smaller to make current reputation value increase slower. Prevention of over-control . To prevent potential centralization and promote fairness, consensus nodes are not allowed to propose two consecutive blocks. Thus, the increase of reputation in consensus nodes is relatively evenly.","title":"Incentive"},{"location":"consensus/por/#punishment","text":"Punishment mechanism is adopted to penalize bad behaviors. There are two kinds of punishment, including collateral and reputation, which can be on all nodes in the consensus group or the node with malicious behaviors. If nodes in the consensus group behave maliciously, and other honest nodes in the consensus group do not detect malicious behaviors, then all nodes in the consensus group should be penalized. If honest nodes in the consensus group detect malicious behaviors of malicious nodes, only nodes with malicious behaviors will be penalized. Malicious behaviors will have a negative impact on reputation Cl_R = Cl_R / 2. The cumulative reputation will be halved and current reputation will be reset to 0, as Cu_R = 0","title":"Punishment"}]}